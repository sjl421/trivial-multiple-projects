[1]:http://tools.ietf.org/html/rfc863
[2]:http://netty.io/4.0/api/io/netty/channel/ChannelInboundHandlerAdapter.html
[3]:http://netty.io/4.0/api/io/netty/channel/ChannelInboundHandler.html
[4]:http://netty.io/4.0/api/io/netty/buffer/ByteBuf.html

User guide for 4.x
==================

## Preface

### The Problem

Nowadays we use general purpose applications or libraries to communicate with each other. For example, we often use an HTTP client library to retrieve information from a web server and to invoke a remote procedure call via web services. However, a general purpose protocol or its implementation sometimes does not scale very well. It is like how we don't use a general purpose HTTP server to exchange huge files, e-mail messages, and near-realtime messages such as financial information and multiplayer game data. What's required is a highly optimized protocol implementation which is dedicated to a special purpose.For example, you might want to implement an HTTP server which is optimized for AJAX-based chat application, media streaming, or large file transfer. You could even want to design and implement a whole new protocol which is precisely tailored to your need. Another inevitable case is when you have to deal with a legacy proprietary protocol to ensure the interoperability with an old system. What matters in this case is how quickly we can implement that protocol while not sacrificing the stability and performance of the resulting application. 

## The Solution

The Netty project is an effort to provide an asynchronous event-driven network application framework and tooling for the rapid development of maintainable high-performance Â· high-scalability protocol servers and clients.

Some users might already have found other network application framework that claims to have the same advantage, and you might want to ask what makes Netty so different from them. 

The answer is the philosophy it is built on. Netty is designed to give you the most comfortable experience both in terms of the API and the implementation from the day one. It is not something tangible but you will realize that this philosophy will make your life much easier as you read this guide and play with Netty.

## Getting Started

### Before Getting Started

```xml
<dependencies>
  <dependency>
    <groupId>io.netty</groupId>
    <artifactId>netty</artifactId> <!-- Use 'netty-all' for 4.0 or above -->
    <version>X.Y.Z.Q</version>
    <scope>compile</scope>
  </dependency>
</dependencies>
```

### Writing a Discard Server

The most simplistic protocol in the world is not 'Hello, World!' but [DISCARD][1]. It's a protocol which discards any received data without any response.

To implement the DISCARD protocol, the only thing you need to do is to ignore all received data. Let us start straight from the handler implementation, which handles I/O events generated by Netty.

```java
/**
 * Created by charlie.du on 2017/4/26.
 *
 * Handles a server-side channel
 */
public class DiscardServerHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        // Discard the received data silently
        ((ByteBuf) msg).release();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        // Close the connection when an exception is raised
        cause.printStackTrace();
        ctx.close();
    }
}
```

- DiscardServerHandler extends [ChannelInboundHandlerAdapter][2], which is an implementation of [ChannelInboundHandler][3]. [ChannelInboundHandler][3] provides various event handler methods that you can override. For now, it is just enough to extend [ChannelInboundHandlerAdapter][2] rather than to implement the handler interface by yourself.
- We override the **channelRead()** event handler method here. This method is called with the received message, whenever new data is received from a client. In this example, the type of the received message is [ByteBuf][4].
- To implement the **DISCARD** protocol, the handler has to ignore the received message. [ByteBuf][4] is a reference-counted object which has to be released explicitly via the **release()** method. Please keep in mind that it is the handler's responsibility to release any reference-counted object passed to the handler. Usually, **channelRead()** handler method is implemented like the following:

```java
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    try {
        // Do something with msg
    } finally {
        ReferenceCountUtil.release(msg);
    }
}
```
























































